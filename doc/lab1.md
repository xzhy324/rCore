

# 过程记录

## 1.内核第一条指令

* 如何得到一个能够在 Qemu 上成功运行的内核镜像呢？
* 首先我们需要通过链接脚本调整内核可执行文件的内存布局，使得内核被执行的第一条指令位于地址 `0x80200000` 处，同时代码段所在的地址应低于其他段。这是因为 Qemu 物理内存中低于 `0x80200000` 的区域并未分配给内核，而是主要由 RustSBI 使用。
* 其次，我们需要将内核可执行文件中的元数据丢掉得到内核镜像，此内核镜像仅包含实际会用到的代码和数据。这则是因为 Qemu 的加载功能过于简单直接，它直接将输入的文件逐字节拷贝到物理内存中，因此也可以说这一步是我们在帮助 Qemu 手动将可执行文件加载到物理内存中。
* 下一节我们将成功生成内核镜像并在 Qemu 上验证控制权被转移到内核。

### 链接脚本入门

第 1 行我们设置了目标平台为 riscv ；第 2 行我们设置了整个程序的入口点为之前定义的全局符号 `_start`；

第 3 行定义了一个常量 `BASE_ADDRESS` 为 `0x80200000` ，也就是我们之前提到的初始化代码被放置的地址；

从第 5 行开始体现了链接过程中对输入的目标文件的段的合并。其中 `.` 表示当前地址，也就是链接器会从它指向的位置开始往下放置从输入的目标文件中收集来的段。我们可以对 `.` 进行赋值来调整接下来的段放在哪里，也可以创建一些全局符号赋值为 `.` 从而记录这一时刻的位置。我们还能够看到这样的格式：

```
.rodata : {
    *(.rodata)
}
```

冒号前面表示最终生成的可执行文件的一个段的名字，花括号内按照放置顺序描述将所有输入目标文件的哪些段放在这个段中，每一行格式为 `<ObjectFile>(SectionName)`，表示目标文件 `ObjectFile` 的名为 `SectionName` 的段需要被放进去。我们也可以使用通配符来书写 `<ObjectFile>` 和 `<SectionName>` 分别表示可能的输入目标文件和段名。因此，最终的合并结果是，在最终可执行文件中各个常见的段 `.text, .rodata .data, .bss` 从低地址到高地址按顺序放置，每个段里面都包括了所有输入目标文件的同名段，且每个段都有两个全局符号给出了它的开始和结束地址（比如 `.text` 段的开始和结束地址分别是 `stext` 和 `etext` ）。

第 12 行我们将包含内核第一条指令的 `.text.entry` 段放在最终的 `.text` 段的最开头，同时注意到在最终内存布局中代码段 `.text` 又是先于任何其他段的。因为所有的段都从 `BASE_ADDRESS` 也即 `0x80200000` 开始放置，这就能够保证内核的第一条指令正好放在 `0x80200000` 从而能够正确对接到 Qemu 上。

### 出现问题

在添加`entry.asm`之后编译报错：

```bash
error[E0658]: use of unstable library feature 'global_asm': `global_asm!` is not stable enough for use and is subject to change
 --> src/main.rs:5:5
  |
5 | use core::arch::global_asm;
  |     ^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: see issue #35119 <https://github.com/rust-lang/rust/issues/35119> for more information
  = help: add `#![feature(global_asm)]` to the crate attributes to enable
```

问题及解决方案：安装了旧版本的rust nightly，更新rust nightly ver 至最新版，并重新安装了相关的工具链，在使用

```bash
rustup target add riscv64gc-unknown-none-elf
cargo install cargo-binutils --vers =0.3.3
rustup component add llvm-tools-preview
rustup component add rust-src
```

安装时，指定ver = 0.3.3报错，删除版本参数重新安装

消除了错误



## task done

1. 编写内核第一条指令
2. 调整内核的内存布局
3. 手动加载内核可执行文件
4. 基于 GDB 验证启动流程

## 2.为内核支持函数调用

1. 如何使得函数返回时能够跳转到调用该函数的下一条指令，即使该函数在代码中的多个位置被调用？

   在调用函数中保存调用函数的地址信息到ra（x1）寄存器当中

2. 对于一个函数而言，保证它调用某个子函数之前，以及该子函数返回到它之后（某些）通用寄存器的值保持不变有何意义？

   保证函数能够多级调用，保证子函数调用不会破坏调用函数原本的数据等等

3. 调用者函数和被调用者函数如何合作保证调用子函数前后寄存器内容保持不变？调用者保存和被调用者保存寄存器的保存与恢复各自由谁负责？它们暂时被保存在什么位置？它们于何时被保存和恢复（如函数的开场白/退场白）？

4. 在 RISC-V 架构上，调用者保存和被调用者保存寄存器如何划分（特别地，思考 sp 和 ra 是调用者还是被调用者保存寄存器？为什么？）？如何使用寄存器传递函数调用的参数和返回值？

   1. sp是被调用者保存，需要记录当前函数栈的开头，并在运行的结尾还原sp指针至调用前状态
   2. ra是调用者保存，需要记录调用函数的地址信息



## 3.基于sbi服务完成输入和关机

tasks：

1. 使用 RustSBI 提供的服务 =>sbi.rs
2. 实现格式化输出 => console.rs ，封装了sbi中的CONSOLE_PUTCHAR,
3. 处理致命错误







